import json
import os
from typing import Dict, List, Optional, Any, Generator
#from .llm_service import LLMService
import dspy
#from langchain_community.tools.yahoo_finance_news import YahooFinanceNewsTool
from dspy.adapters.types.tool import Tool
import json
#import yfinance as yf
import asyncio
import pandas as pd
from gradio import ChatMessage
from queue import Queue
import threading
import gradio as gr
from ..paperQA.query_agent import QueryAgent

# Configure DSPy
dspy.configure(lm=dspy.LM('ollama_chat/qwen3:4b', api_base='http://localhost:11434', api_key=''))

class CopilotProjectPortfolioService:
    def __init__(self) -> None:
        """Initialize CopilotService with agent modules"""
        #self.llm_service = llm_service
        self.agents : Dict[str, dspy.Module] = self._create_agents()
    
    def _create_agents(self) -> Dict[str, dspy.Module]:
        """Create agent instances"""
        return {
            "Local Project Proposals": QueryAgent(),  #(self.llm_service),
            "External Project Proposals": QueryAgent(),  #(self.llm_service),
        }
    
    def get_agent_list(self) -> List[str]:
        """Returns a list of available agent names."""
        return sorted(list(self.agents.keys()))
    
    def get_agent_details(self, agent_name: str = None) -> Dict[str, str]:
        """Returns the configuration for a specific agent or all agents."""
        all_details = {
            "Local Project Proposals": {
                "short_description": "A local project proposal assistant that can answer questions about projects proposals generated by the user.",
                "full_description": "A local project proposal assistant that can answer questions about projects proposals generated by the user.",
                "tools": []
            },
            "External Project Proposals": {
                "short_description": "A external project proposal assistant that can answer questions about projects proposals generated outside the app.",
                "full_description": "A external project proposal assistant that can answer questions about projects proposals generated outside the app.",
                "tools": []
            },
        }
        
        if agent_name:
            return all_details.get(agent_name)
        return all_details

    def get_quick_actions(self, agent_name: str) -> List[Dict[str, str]]:
        """Returns quick action buttons for the specified agent."""
        if not agent_name:
            return []
        
        # Dummy implementation - different actions per agent
        actions_map = {
            "Local Project Proposals": [
                {"label": "Review Proposals", "icon": "ðŸ“‹"},
                {"label": "Compare Projects", "icon": "âš–ï¸"},
                {"label": "Status Update", "icon": "ðŸ“Š"}
            ],
            "External Project Proposals": [
                {"label": "Import Proposal", "icon": "ðŸ“¥"},
                {"label": "External Analysis", "icon": "ðŸ”"},
                {"label": "Benchmark Compare", "icon": "ðŸ“ˆ"}
            ]
        }
        
        return actions_map.get(agent_name, [])

    def reload(self) -> None:
        """Reload agent configurations - placeholder for UI compatibility."""
        print(f"Reloading {self.__class__.__name__} - agents recreated")
        self.agents = self._create_agents()
    
    def chat_with_agent(self, agent_name: str, message: str, llm_history: List[Dict[str, Any]], provider: str = "ollama"):
        """Route chat to the appropriate agent module"""
        
        agent: dspy.Module = self.agents.get(agent_name)
        if not agent:
            # Add a return statement for the flow_log as well to avoid unpacking errors.
            return f"Error: Agent '{agent_name}' not found.", []

        # The new QueryAgent orchestrator only needs the user_request.
        # The 'forward' method in the new QueryAgent handles the entire workflow.
        answer = agent(user_request=message)
        
        # The new agent architecture doesn't produce a separate flow_log.
        # We return the answer and an empty list for UI compatibility.
        return answer, []

